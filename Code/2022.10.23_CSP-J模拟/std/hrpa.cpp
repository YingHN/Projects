#include <bits/stdc++.h>
using namespace std;
int main()
{
	// 这题是"博弈论"(即多人**决策对抗**求最优), 一般是**手模找规律**
	// n	Min	n−Min
	// 1	1	  0
	// 2	2	  0
	// 3	3	  0
	// 4	1	  3
	// 5	5	  0
	// 6	1   5
	// 7	2	  5
	// 8	8	  0
	// 9	1	  8
	// 10	2  	8
	// 11	3	  8
	// 12	1	  1
	// 13	13	0
	// ...........
	// 其中, 这一题又是"斐波那契博弈(Fibonacci Nim)"
	// 齐肯多夫定理:
	// > 任何正整数都可以表示成若干个不连续的斐波那契数之和。
	// 可以引出:
	// > 先手取完最小的那一堆后, 后手无法一次性取完次小的那一堆.
	// > 则次小的一堆的最后一块石子一定由先手取到,
	// > 于是先手一定能取到最大的那一堆的最后一块, 即整堆石子的最后一块.

	long long n, x, y, z;
	cin >> n;
	while (1)
	{
		// 小数据打表, 免去对于"边界条件"的讨论
		if (n == 1)
		{
			puts("1");
			return 0;
		}
		if (n == 2)
		{
			puts("2");
			return 0;
		}

		// 求不大于n的斐波那契数
		x = 1, y = 2, z = 3;
		while (z < n)
			x = y, y = z, z = x + y;

		if (z == n)
		{
			printf("%lld", z);
			return 0
		}
		else
			n -= y;
	}
	return 0;
}
